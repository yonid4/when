# README for AI Assistants

**Last Updated:** December 13, 2025
**Purpose:** This document provides critical context and rules for AI assistants working on the When event coordination app.

---

## ðŸŽ¯ Application Purpose

**When** is an event coordination app that **minimizes user interaction** by intelligently finding optimal meeting times.

### Core User Flow
1. **Coordinator** creates an event with a date range and invites participants
2. **System** analyzes all participants' Google Calendars automatically
3. **AI (Gemini)** suggests optimal meeting times based on availability and preferences
4. **Coordinator** selects a suggested time or chooses their own
5. **System** creates Google Calendar event and invites all participants

### Key Philosophy
- **Minimize manual coordination** - The app does the heavy lifting
- **Smart automation** - AI-powered suggestions, automatic calendar sync
- **Seamless integration** - Works with existing Google Calendar workflows

---

## ðŸ—ï¸ Architecture Overview

### Stack Summary
- **Frontend:** React 18 + Chakra UI + React Router
- **Backend:** Flask 3.1 (Python) with blueprint architecture
- **Database:** Supabase (PostgreSQL) with real-time subscriptions
- **AI:** Google Gemini for time proposal generation
- **External APIs:** Google Calendar API (OAuth2 flow)
- **Background Jobs:** APScheduler for proposal regeneration and calendar sync

### Project Structure
```
when/
â”œâ”€â”€ backend/
â”‚   â”œâ”€â”€ app/
â”‚   â”‚   â”œâ”€â”€ models/          # Pydantic models for database entities
â”‚   â”‚   â”œâ”€â”€ routes/          # Flask blueprints (thin handlers)
â”‚   â”‚   â”œâ”€â”€ services/        # Business logic (MUST be here, not in routes)
â”‚   â”‚   â”œâ”€â”€ utils/           # Helpers, decorators, validators
â”‚   â”‚   â””â”€â”€ background_jobs/ # Scheduled tasks (proposal regen, sync)
â”‚   â””â”€â”€ tests/
â”œâ”€â”€ frontend/
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ components/      # Reusable UI components
â”‚   â”‚   â”œâ”€â”€ pages/           # Route-level components
â”‚   â”‚   â”œâ”€â”€ hooks/           # Custom React hooks (useApiCall, useAuth, etc.)
â”‚   â”‚   â”œâ”€â”€ services/        # API communication layer
â”‚   â”‚   â””â”€â”€ utils/           # Frontend utilities
â””â”€â”€ migrations/              # SQL migration files (001-005)
```

---

## ðŸ”‘ Critical Database Schema

### Main Tables
- **`profiles`** - User profile info
- **`events`** - Event details with AI proposal tracking fields
  - `last_proposal_generation` - Timestamp of last AI generation
  - `proposal_invalidation_reason` - Why proposals were invalidated
- **`event_participants`** - Many-to-many users â†” events
- **`busy_slots`** - User busy times from Google Calendar (cached)
- **`preferred_slots`** - User-marked preferred times for events
- **`proposed_times`** - AI-generated time proposals (cached with metadata)
- **`notifications`** - In-app notifications
- **`event_invitations`** - Invitation tracking and RSVP status

### Important ID Fields
- **`id`** (UUID) - Internal database primary key
- **`uid`** (12-char string) - User-facing shareable ID used in URLs
- Always use **UID** in frontend URLs and API routes where possible
- Use **UUID** only for internal database operations

---

## ðŸš¨ CRITICAL RULES - MUST FOLLOW

### 1. Import Organization (STRICTLY ENFORCED)
```javascript
// âŒ WRONG - External imports first
import React from "react";
import { useAuth } from "../hooks/useAuth";

// âœ… CORRECT - Local imports ALWAYS first
import { useAuth } from "../hooks/useAuth";
import { EventCard } from "../components/events/EventCard";

import React, { useState } from "react";
import axios from "axios";
```

```python
# âŒ WRONG - External imports first
import os
from flask import Flask
from app.models.event import Event

# âœ… CORRECT - Local imports ALWAYS first
from app.models.event import Event
from app.services.events import EventService

import os
from flask import Flask, jsonify
```

### 2. Business Logic Placement
- **NEVER put business logic in route handlers** - Routes should be thin
- **ALL business logic goes in `services/`** - Always
- Routes handle: request parsing, calling services, returning responses
- Services handle: database operations, calculations, external API calls

```python
# âŒ WRONG - Logic in route
@events_bp.route("/events", methods=["POST"])
def create_event():
    data = request.json
    event = supabase.table("events").insert(data).execute()  # âŒ Direct DB call
    return jsonify(event)

# âœ… CORRECT - Logic in service
@events_bp.route("/events", methods=["POST"])
@token_required
def create_event(user_id):
    data = request.json
    event = EventService.create_event(user_id, data)  # âœ… Service handles logic
    return jsonify(event)
```

### 3. Error Handling - Use Sparingly
```python
# âŒ WRONG - Unnecessary try-catch
try:
    user_id = data.get("user_id")  # âŒ Simple assignment doesn't need try-catch
except Exception as e:
    return {"error": str(e)}

# âœ… CORRECT - Only for critical operations
try:
    response = requests.post(GOOGLE_API_URL, data=payload)  # âœ… External API call
    response.raise_for_status()
except requests.RequestException as e:
    logger.error(f"Google API error: {e}")
    return {"error": "Failed to sync calendar"}
```

**Use try-catch ONLY for:**
- External API calls (Google Calendar, Gemini AI)
- File operations
- Database transactions that must succeed/fail together
- **NOT for:** Simple assignments, basic calculations, routine queries

### 4. Code Style
- **Strings:** Double quotes everywhere (`"hello"` not `'hello'`)
- **JavaScript:** 2-space indentation, functional components with hooks
- **Python:** 4-space indentation, snake_case functions, PascalCase classes
- **Line length:** Under 100 characters when possible

### 5. Security - NEVER HARDCODE SECRETS
```python
# âŒ ABSOLUTELY FORBIDDEN
GOOGLE_API_KEY = "AIzaSyD..."  # âŒ NEVER!
DATABASE_URL = "postgresql://..."  # âŒ NEVER!

# âœ… ALWAYS use environment variables
GOOGLE_API_KEY = os.getenv("GOOGLE_API_KEY")
SUPABASE_URL = os.getenv("SUPABASE_URL")
```

### 6. Authentication Patterns
- **Backend:** Use `@token_required` decorator (passes `user_id` to function)
- **Frontend:** Use `useAuth()` hook for user context
- All protected routes MUST verify JWT tokens
- User context should be passed via decorators, not manually extracted

### 7. Timezone Handling (CRITICAL)
- **ALWAYS store times in UTC** in the database
- Convert to user timezone **ONLY for display**
- Use `date-fns` (frontend) or `python-dateutil` (backend)
- Handle DST transitions properly

```python
# âœ… CORRECT
start_time_utc = convert_to_utc(user_time, user_timezone)
db.insert({"start_time": start_time_utc})  # Store in UTC

# Display
user_time = convert_from_utc(db_time, user_timezone)  # Convert for display
```

---

## ðŸ§© Common Patterns to Follow

### Frontend API Calls
```javascript
// âœ… Use apiService.js for all API calls
import apiService from "../services/apiService";

const { events } = apiService;

// Good - Centralized error handling
const fetchEvents = async () => {
  try {
    const data = await events.getAll();
    setEvents(data);
  } catch (error) {
    console.error("Failed to fetch events:", error);
  }
};
```

### Backend Route Pattern
```python
# âœ… Standard route structure
from app.utils.decorators import token_required
from app.services.events import EventService

@events_bp.route("/events", methods=["POST"])
@token_required  # Injects user_id
def create_event(user_id):
    data = request.json

    # Validate
    if not data.get("title"):
        return jsonify({"error": "Title required"}), 400

    # Call service
    event = EventService.create_event(user_id, data)

    # Return response
    return jsonify(event), 201
```

### AI Time Proposals Pattern
```python
# âœ… Always use caching, invalidate when event data changes
from app.services.time_proposal import TimeProposalService

# Generate proposals (uses cache if available)
proposals = TimeProposalService.generate_proposals(event_uid, num_suggestions=5)

# Force refresh (coordinator only, expensive operation)
proposals = TimeProposalService.regenerate_proposals(event_uid)
```

---

## ðŸš« What NOT to Do

### 1. Don't Create Unnecessary Files
- **NEVER create markdown files** unless explicitly requested
- **PREFER editing existing files** over creating new ones
- Don't create documentation files proactively

### 2. Don't Break Existing Patterns
- If you see a pattern (e.g., all services inherit from `BaseService`), follow it
- Don't introduce new ways of doing things that already have established patterns
- Check existing code before implementing something "new"

### 3. Don't Skip Testing Critical Paths
- **MUST test:** Auth flows, availability calculation, timezone handling
- **MUST mock:** External API calls (Google Calendar, Gemini)
- Write tests for complex business logic

### 4. Don't Ignore Performance
- Use React.memo for expensive components
- Debounce user input for search/filtering
- Implement caching for expensive calculations (see AI proposals)
- Use background jobs for heavy processing

### 5. Don't Forget Real-time Features
- Clean up Supabase subscriptions in `useEffect` cleanup
- Handle connection drops gracefully
- Batch updates to avoid UI thrashing

---

## ðŸ“‹ Key API Endpoints Reference

### Events
- `GET /api/events` - List user's events
- `POST /api/events` - Create event
- `GET /api/events/<event_uid>` - Get event by UID
- `PUT /api/events/<event_uid>` - Update event
- `DELETE /api/events/<event_uid>` - Delete event

### AI Time Proposals (NEW)
- `POST /api/events/<event_uid>/propose-times` - Get cached or generate proposals
  - Body: `{"num_suggestions": 5, "force_refresh": false}`
- `POST /api/events/<event_uid>/propose-times/refresh` - Force regenerate (coordinator only)

### Preferred Slots
- `POST /api/preferred_slots` - Add user's preferred times
- `GET /api/preferred_slots/<event_uid>` - Get all preferred slots
- `DELETE /api/preferred_slots/<slot_id>` - Delete slot

### Event Finalization
- `POST /api/events/<event_uid>/finalize` - Finalize to specific time (coordinator only)
- `GET /api/events/<event_uid>/finalization-status` - Get status

### Notifications
- `GET /api/notifications` - Get user's notifications
- `PUT /api/notifications/<notification_id>/read` - Mark as read
- `PUT /api/notifications/read-all` - Mark all as read

### Google Calendar
- `GET /api/calendar/connection-status` - Check connection
- `POST /api/calendar/sync` - Sync Google Calendar (differential)

---

## ðŸ”„ Recent Major Changes (Nov 5 - Dec 13, 2025)

### New Features
- âœ… **AI Time Proposals** - Gemini integration with smart caching
- âœ… **Preferred Slots** - Users can mark preferred times
- âœ… **Event Invitations** - RSVP tracking system
- âœ… **Notifications** - In-app notification system
- âœ… **Event Finalization** - Coordinator finalizes events
- âœ… **Redesigned UI** - New landing, dashboard, event creation wizard

### New Files to Be Aware Of
- Backend: `time_proposal.py`, `proposal_regeneration.py`, `proposed_time.py`
- Frontend: `ProposedTimesModal.jsx`, `useApiCall.js`, `apiService.js`
- Frontend: `Landing.jsx`, `DashboardTemp.jsx`, `EventCreate.jsx`, `EventTemp.jsx`

### Technical Improvements
- Enhanced auth decorators pass `user_id` automatically
- Differential calendar sync with dynamic time windows
- Smart proposal caching with background regeneration
- Comprehensive `apiService.js` consolidates all API calls

---

## ðŸŽ¨ UI/UX Considerations

### Design System
- **Colors:** Purple primary, Green secondary, Amber accent
- **Components:** Chakra UI for consistency
- **Animations:** Framer Motion for smooth transitions
- **Responsive:** Mobile-first design

### User Experience Principles
- **Minimize clicks** - Automate wherever possible
- **Clear feedback** - Loading states, error messages
- **Smart defaults** - Pre-fill based on context
- **Progressive disclosure** - Show complexity only when needed

---

## ðŸ§ª Testing Checklist

When making changes, ensure:
- [ ] No hardcoded secrets or API keys
- [ ] Timezone handling is correct (store UTC, display local)
- [ ] Error handling for external API calls
- [ ] Real-time features work (Supabase subscriptions)
- [ ] Responsive design on mobile
- [ ] Database operations are efficient (no N+1 queries)
- [ ] Import order follows the rules (local first, external second)
- [ ] Business logic is in services, not routes

---

## ðŸ“ž Questions to Ask Before Implementation

If you're unsure about any of these, ASK the user:

1. **Scope:** Does this require modifying existing features or creating new ones?
2. **Data flow:** Which tables/models are affected?
3. **User role:** Is this coordinator-only, participant-only, or both?
4. **Real-time:** Should changes propagate to other users instantly?
5. **Performance:** Will this impact users with many events/participants?
6. **Breaking changes:** Will this affect existing data or APIs?

---

## ðŸ’¡ Pro Tips

1. **Check existing patterns first** - Don't reinvent the wheel
2. **Read the .cursorrules file** - Contains critical standards
3. **Use apiService.js** - Don't create ad-hoc API calls
4. **Follow the service layer pattern** - Routes are thin, services are thick
5. **Test with real Google Calendar** - Mock data only goes so far
6. **Consider caching** - Expensive operations should be cached (see AI proposals)
7. **Think about edge cases** - Empty states, no participants, no availability
8. **Mobile users exist** - Test responsive design

---

## ðŸš€ Getting Started Quickly

1. Read this README fully (you're doing it!)
2. Review [README.md](README.md) for setup instructions
3. Check [.cursorrules](.cursorrules) for detailed coding standards
4. Look at existing code patterns before writing new code
5. When in doubt, ask the user for clarification

---

**Remember:** This app is about **minimizing user effort**. Every feature should reduce manual coordination and make event scheduling effortless.
